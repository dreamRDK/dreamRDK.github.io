{"compress":true,"commitItems":[["6731b42c-2713-4c5b-bc77-b5879b087bbb",1536759997143,"---\nlayout: post\ntitle: 'Effective Java 读书笔记 01'\nsubtitle: '创建和销毁对象'\ndate: 2018-09-09\ncategories: 技术\ntags:EffectiveJava\n---\n## 1. 用静态工厂方法代替构造器\n\n> 主要优点：\n\n### 1.1 静态工厂方法不同于构造器,它有名称\n静态工厂方法可以通过名称获取不同的对象示例，二构造器通过传参获取不同的实例不便于使用，容易搞混。\n\n### 1.2 静态工厂方法不必每次调用的时候都创建新对象\n静态工厂方法可以预先创建好实例，每次调用都返回相同的实例，从而实现重复利用,提升程序性能。\n\n### 1.3 静态工厂方法可以返回任何子类对象\n这种方式适用于接口框架，通过私有对象的构造方法，通过工厂提供对象，当对象有新的子类时对接口调用者来说，影响小。\n\n例如java 的 JDBC 连接，它就是一个服务提供者框架，java 为各数据库厂商提供多个实现，各厂商实现的是同一个服务，即进行数据库连接操作，而客户端调用java 的API，只是注册的数据库连接驱动不同，实现解耦。\n\n服务提供者框架包括四大部分：\n1. 提供者注册 API （Provider Registration API）\n2. 服务接口 （Service Interface）\n3. 服务访问者 API （Service Access API）\n4. 服务提供者接口 （Service Provider Interface）\n\n\n一下是简单的实现\n```java\n// Service Interface \npublic interface Service {\n\t// 定义服务的特有方法\n}\n\n// Service Provider Interface\npublic interface Provider {\n\tService newService();\n}\n\n// Noninstantiable class for service registration and access\npublic class Services {\n\tprivate Services{} // 私有化构造方法\n\t\n\t// Maps service names to services\n\tprivate static finam Map<String, Provider> providers = new ConcurrentHashMap<String, Provider>();\n\tpublic static final String DEFAULT_PROVIDER_NAME = \"<def>\";\n\n\t// Provider registration API\n\tpublic static void registerDefaultProvider(Provider p) {\n\t\tregisterProvider(DEFAULT_PROVIDER_NAME, p);\n\t}\n\tpublic static void registerProvider(String name, Provider p) {\n\t\tproviders.put(name,p);\n\t}\n\t\n\t// Service access API\n\tpublic static Service newInstance() {\n\t\treturn newInstance(DEFAULT_PROVIDER_NAME);\n\t}\n\tpublic static Service newInstance(String name) {\n\t\tProvider p = providers.get(name);\n\t\tif(p==null) {\n\t\t\tthrow new IllegalArgumentException(\"没有该名称的服务提供者：\"+name);\n\t\t}\n\t\treturn p.newService();\n\t}\n}\n```\n> 缺点：\n### 1. 类被私有化不能被继承\n### 2. 和其他静态方法没有区别，需要区分是否是静态工厂方法\n\n## 2. 构造器有多个参数时考虑用构建器 Builder\n这种方式更容易阅读和使用，当然缺点就是需要先创建构建器，对性能有影响。\n> 示例\n```java\n// Builder 示例\npublic class NutritionFacts {\n\tprivate final int servingSize;\n\tprivate final int servings;\n\tprivate final int calories;\n\tprivate final int fat;\n\tprivate final int sodium;\n\tprivate final int carbohydrate;\n\t\n\tpublic static class Builder {\n\t\t// 必须参数\n\t\tprivate final int servingSize;\n\t\tprivate final int servings;\n\t\t// 可选参数 初始化为默认值\n\t\tprivate  int calories = 0;\n\t\tprivate  int fat = 0;\n\t\tprivate  int sodium = 0;\n\t\tprivate  int carbohydrate = 0;\n\t\t\n\t\tpublic Builder(int servingSize, int servings) {\n\t\t\tthis.servingSize = servingSize;\n\t\t\tthis.servings = servings;\n\t\t}\n\t\t\n\t\tpublic Builder calories(int val) {\n\t\t\tcalories = val;\n\t\t\treturn this;\n\t\t}\n\t\tpublic Builder fat (int val) {\n\t\t\tfat = val;\n\t\t\treturn this;\n\t\t}\n\t\tpublic Builder sodium (int val) {\n\t\t\tsodium = val;\n\t\t\treturn this;\n\t\t}\n\t\tpublic Builder carbohydrate (int val) {\n\t\t\tcarbohydrate = val;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic NutritionFacts build() {\n\t\t\treturn new NutritionFacts(this);\n\t\t}\n\t}\n\tprivate NutritionFacts (Builder builder) {\n\t\tservingSize = builder.servingSize ;\n\t\tservings = bulider.servings ;\n\t\tcalories = bulider.calories ;\n\t\tfat = bulider.fat ;\n\t\tsodium = bulider.sodium ;\n\t\tcarbohydrate = bulider.carbohydrate ;\n\t}\n\n// 客户端调用\nNutritionFacts nf = new NutritionFacts.Builder(200,8).calories(100).fat(0).build();\n```\n## 3. 用私有构造器或者枚举强化 Singleton 属性\n## 4. 私有构造器强化不可实例化能力\n## 5.避免创建不必要的对象\n尽量复用对象，而不是频繁创建\n## 6. 消除过期的对象引用\n及时清空对象引用\n内存泄漏的三种常见类型\n* 类自己管理内存\n* 缓存\n* 监听器和其他回调\n## 7. 避免使用终结方法\n\n",[[1536759940571,["DreamK@RDK-PC",[[-1,46,"1"]],[47,47],[46,46]]],[1536759941323,["DreamK@RDK-PC",[[1,46,"2"]],[46,46],[47,47]]],[1536759946347,["DreamK@RDK-PC",[[-1,60,"创建和销毁对象"]],[67,67],[60,60]]],[1536759963447,["DreamK@RDK-PC",[[1,60,"对象通用方法"]],[60,60],[66,66]]],[1536759973065,["DreamK@RDK-PC",[[-1,126,"1. 用静态工厂方法代替构造器\n\n> 主要优点：\n\n### 1.1 静态工厂方法不同于构造器,它有名称\n静态工厂方法可以通过名称获取不同的对象示例，二构造器通过传参获取不同的实例不便于使用，容易搞混。\n\n### 1.2 静态工厂方法不必每次调用的时候都创建新对象\n静态工厂方法可以预先创建好实例，每次调用都返回相同的实例，从而实现重复利用,提升程序性能。\n\n### 1.3 静态工厂方法可以返回任何子类对象\n这种方式适用于接口框架，通过私有对象的构造方法，通过工厂提供对象，当对象有新的子类时对接口调用者来说，影响小。\n\n例如java 的 JDBC 连接，它就是一个服务提供者框架，java 为各数据库厂商提供多个实现，各厂商实现的是同一个服务，即进行数据库连接操作，而客户端调用java 的API，只是注册的数据库连接驱动不同，实现解耦。\n\n服务提供者框架包括四大部分：\n1. 提供者注册 API （Provider Registration API）\n2. 服务接口 （Service Interface）\n3. 服务访问者 API （Service Access API）\n4. 服务提供者接口 （Service Provider Interface）\n\n\n一下是简单的实现\n```java\n// Service Interface \npublic interface Service {\n\t// 定义服务的特有方法\n}\n\n// Service Provider Interface\npublic interface Provider {\n\tService newService();\n}\n\n// Noninstantiable class for service registration and access\npublic class Services {\n\tprivate Services{} // 私有化构造方法\n\t\n\t// Maps service names to services\n\tprivate static finam Map<String, Provider> providers = new ConcurrentHashMap<String, Provider>();\n\tpublic static final String DEFAULT_PROVIDER_NAME = \"<def>\";\n\n\t// Provider registration API\n\tpublic static void registerDefaultProvider(Provider p) {\n\t\tregisterProvider(DEFAULT_PROVIDER_NAME, p);\n\t}\n\tpublic static void registerProvider(String name, Provider p) {\n\t\tproviders.put(name,p);\n\t}\n\t\n\t// Service access API\n\tpublic static Service newInstance() {\n\t\treturn newInstance(DEFAULT_PROVIDER_NAME);\n\t}\n\tpublic static Service newInstance(String name) {\n\t\tProvider p = providers.get(name);\n\t\tif(p==null) {\n\t\t\tthrow new IllegalArgumentException(\"没有该名称的服务提供者：\"+name);\n\t\t}\n\t\treturn p.newService();\n\t}\n}\n```\n> 缺点：\n### 1. 类被私有化不能被继承\n### 2. 和其他静态方法没有区别，需要区分是否是静态工厂方法\n\n## 2. 构造器有多个参数时考虑用构建器 Builder\n这种方式更容易阅读和使用，当然缺点就是需要先创建构建器，对性能有影响。\n> 示例\n```java\n// Builder 示例\npublic class NutritionFacts {\n\tprivate final int servingSize;\n\tprivate final int servings;\n\tprivate final int calories;\n\tprivate final int fat;\n\tprivate final int sodium;\n\tprivate final int carbohydrate;\n\t\n\tpublic static class Builder {\n\t\t// 必须参数\n\t\tprivate final int servingSize;\n\t\tprivate final int servings;\n\t\t// 可选参数 初始化为默认值\n\t\tprivate  int calories = 0;\n\t\tprivate  int fat = 0;\n\t\tprivate  int sodium = 0;\n\t\tprivate  int carbohydrate = 0;\n\t\t\n\t\tpublic Builder(int servingSize, int servings) {\n\t\t\tthis.servingSize = servingSize;\n\t\t\tthis.servings = servings;\n\t\t}\n\t\t\n\t\tpublic Builder calories(int val) {\n\t\t\tcalories = val;\n\t\t\treturn this;\n\t\t}\n\t\tpublic Builder fat (int val) {\n\t\t\tfat = val;\n\t\t\treturn this;\n\t\t}\n\t\tpublic Builder sodium (int val) {\n\t\t\tsodium = val;\n\t\t\treturn this;\n\t\t}\n\t\tpublic Builder carbohydrate (int val) {\n\t\t\tcarbohydrate = val;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic NutritionFacts build() {\n\t\t\treturn new NutritionFacts(this);\n\t\t}\n\t}\n\tprivate NutritionFacts (Builder builder) {\n\t\tservingSize = builder.servingSize ;\n\t\tservings = bulider.servings ;\n\t\tcalories = bulider.calories ;\n\t\tfat = bulider.fat ;\n\t\tsodium = bulider.sodium ;\n\t\tcarbohydrate = bulider.carbohydrate ;\n\t}\n\n// 客户端调用\nNutritionFacts nf = new NutritionFacts.Builder(200,8).calories(100).fat(0).build();\n```\n## 3. 用私有构造器或者枚举强化 Singleton 属性\n## 4. 私有构造器强化不可实例化能力\n## 5.避免创建不必要的对象\n尽量复用对象，而不是频繁创建\n## 6. 消除过期的对象引用\n及时清空对象引用\n内存泄漏的三种常见类型\n* 类自己管理内存\n* 缓存\n* 监听器和其他回调\n## 7. 避免使用终结方法\n"]],[126,3274],[126,126]]],[1536760042085,["DreamK@RDK-PC",[[1,126,"1. 覆盖 equals 方法的通用约定"]],[126,126],[146,146]]],[1536760042282,["DreamK@RDK-PC",[[1,147,"\n"]],[146,146],[147,147]]],[1536760050592,["DreamK@RDK-PC",[[-1,147,"\n"],[1,148,"》 "]],[147,147],[149,149]]],[1536760051128,["DreamK@RDK-PC",[[-1,148," "]],[149,149],[148,148]]],[1536760051333,["DreamK@RDK-PC",[[-1,147,"》"],[1,148,"\n"]],[148,148],[147,147]]],[1536760052840,["DreamK@RDK-PC",[[-1,147,"\n"],[1,148,"> "]],[147,147],[149,149]]],[1536760077126,["DreamK@RDK-PC",[[1,149,"以下情形可以不使用 equals 方法"]],[149,149],[168,168]]],[1536760083002,["DreamK@RDK-PC",[[-1,156,"使用"],[1,158,"f"]],[156,158],[156,157]]],[1536760083221,["DreamK@RDK-PC",[[1,157,"u"]],[156,157],[156,158]]],[1536760083496,["DreamK@RDK-PC",[[1,158,"'g"]],[156,158],[156,160]]],[1536760084109,["DreamK@RDK-PC",[[-1,156,"fu'g"],[1,160,"覆盖"]],[156,160],[156,158]]],[1536760086393,["DreamK@RDK-PC",[[1,168,"\n\n"]],[168,168],[169,169]]],[1536760088320,["DreamK@RDK-PC",[[-1,169,"\n"],[1,170,"1. "]],[169,169],[172,172]]],[1536760091056,["DreamK@RDK-PC",[[-1,170,". "]],[172,172],[170,170]]],[1536760091365,["DreamK@RDK-PC",[[-1,169,"1"],[1,170,"\n"]],[170,170],[169,169]]],[1536760108453,["DreamK@RDK-PC",[[-1,169,"\n"],[1,170,"* 类的每个实例本周"]],[169,169],[179,179]]],[1536760109059,["DreamK@RDK-PC",[[-1,177,"本周"]],[179,179],[177,177]]],[1536760116091,["DreamK@RDK-PC",[[1,177,"本质上是唯一的"]],[177,177],[184,184]]],[1536760116361,["DreamK@RDK-PC",[[1,184,"\n\n"]],[184,184],[185,185]]],[1536760126467,["DreamK@RDK-PC",[[-1,185,"\n"],[1,186,"* 不关心"]],[185,185],[190,190]]],[1536760131191,["DreamK@RDK-PC",[[-1,187,"不关心"]],[190,190],[187,187]]],[1536760147099,["DreamK@RDK-PC",[[1,187,"使用者并不关心是否"]],[187,187],[196,196]]],[1536760152011,["DreamK@RDK-PC",[[1,194,"类"]],[194,194],[195,195]]],[1536760156992,["DreamK@RDK-PC",[[1,197,"“”"]],[197,197],[199,199]]],[1536760164339,["DreamK@RDK-PC",[[1,198,"逻辑相等"]],[198,198],[202,202]]],[1536760174949,["DreamK@RDK-PC",[[1,203,"，比如"]],[203,203],[206,206]]],[1536760183527,["DreamK@RDK-PC",[[1,206," Random lei"]],[206,206],[217,217]]],[1536760184487,["DreamK@RDK-PC",[[-1,214,"lei"]],[217,217],[214,214]]],[1536760186763,["DreamK@RDK-PC",[[1,214,"类"]],[214,214],[215,215]]],[1536760187161,["DreamK@RDK-PC",[[1,215,"\n\n"]],[215,215],[216,216]]],[1536760224319,["DreamK@RDK-PC",[[-1,216,"\n"],[1,217,"* 父类已经覆盖 equals 方法并且适用于子类"]],[216,216],[241,241]]],[1536760224695,["DreamK@RDK-PC",[[1,241,"\n\n"]],[241,241],[242,242]]],[1536760236171,["DreamK@RDK-PC",[[-1,242,"\n"],[1,243,"* 类是"]],[242,242],[246,246]]],[1536760273835,["DreamK@RDK-PC",[[1,246,"私有的或者包级私有的，equals 方法永远不好"]],[246,246],[270,270]]],[1536760274696,["DreamK@RDK-PC",[[-1,269,"好"]],[270,270],[269,269]]],[1536760278907,["DreamK@RDK-PC",[[1,269,"会被调用"]],[269,269],[273,273]]],[1536760280588,["DreamK@RDK-PC",[[1,273,"\n\n"]],[273,273],[274,274]]],[1536760281237,["DreamK@RDK-PC",[[1,275,"\n"]],[274,274],[275,275]]],[1536760289656,["DreamK@RDK-PC",[[-1,275,"\n"],[1,276,"》"]],[275,275],[276,276]]],[1536760290570,["DreamK@RDK-PC",[[-1,275,"》"]],[276,276],[275,275]]],[1536760293343,["DreamK@RDK-PC",[[-1,274,"\n"],[1,275,">fu"]],[275,275],[277,277]]],[1536760294688,["DreamK@RDK-PC",[[-1,275,"fu"]],[277,277],[275,275]]],[1536760296167,["DreamK@RDK-PC",[[1,275," "]],[275,275],[276,276]]],[1536760323494,["DreamK@RDK-PC",[[1,276,"覆盖 equals 方法时需要遵循的约定"]],[276,276],[296,296]]],[1536760917758,["DreamK@RDK-PC",[[1,296,"\n\n"]],[296,296],[297,297]]],[1536760944017,["DreamK@RDK-PC",[[-1,297,"\n"],[1,298,"* 自反性：对于任何非null值的引用"]],[297,297],[316,316]]],[1536760946886,["DreamK@RDK-PC",[[1,308," "]],[308,308],[309,309]]],[1536760949085,["DreamK@RDK-PC",[[1,313," "]],[313,313],[314,314]]],[1536760961331,["DreamK@RDK-PC",[[-1,314,"值"]],[315,315],[314,314]]],[1536760987469,["DreamK@RDK-PC",[[1,317,"值 x ，x.equals(x) 必须返回 true"]],[317,317],[343,343]]],[1536760988084,["DreamK@RDK-PC",[[1,343,"\n\n"]],[343,343],[344,344]]],[1536761011949,["DreamK@RDK-PC",[[-1,344,"\n"],[1,345,"* 对称性： duiy"]],[344,344],[355,355]]],[1536761012921,["DreamK@RDK-PC",[[-1,351,"duiy"]],[355,355],[351,351]]],[1536761016760,["DreamK@RDK-PC",[[1,351,"对于任何"]],[351,351],[355,355]]],[1536761032688,["DreamK@RDK-PC",[[1,355,"非 null 的引用值 x 和 有"]],[355,355],[372,372]]],[1536761033304,["DreamK@RDK-PC",[[-1,371,"有"]],[372,372],[371,371]]],[1536761052616,["DreamK@RDK-PC",[[1,371,"y，当且仅当 下、"]],[371,371],[380,380]]],[1536761054310,["DreamK@RDK-PC",[[-1,378,"下、"]],[380,380],[378,378]]],[1536761058981,["DreamK@RDK-PC",[[1,378,"x.eques"]],[378,378],[385,385]]],[1536761059760,["DreamK@RDK-PC",[[-1,383,"es"]],[385,385],[383,383]]],[1536761076893,["DreamK@RDK-PC",[[1,383,"als(y) 返回 true 时，"]],[383,383],[400,400]]],[1536761085373,["DreamK@RDK-PC",[[1,400,"y.equals（"]],[400,400],[409,409]]],[1536761086012,["DreamK@RDK-PC",[[-1,408,"（"]],[409,409],[408,408]]],[1536761100926,["DreamK@RDK-PC",[[1,408,"(x) 必须返回 true"]],[408,408],[421,421]]],[1536761101900,["DreamK@RDK-PC",[[1,421,"\n\n"]],[421,421],[422,422]]],[1536761106716,["DreamK@RDK-PC",[[-1,422,"\n"],[1,423,"* chuan"]],[422,422],[429,429]]],[1536761107909,["DreamK@RDK-PC",[[-1,424,"chuan"]],[429,429],[424,424]]],[1536761136256,["DreamK@RDK-PC",[[1,424,"传递性：对于任何非 null 的引用"]],[424,424],[442,442]]],[1536761148900,["DreamK@RDK-PC",[[1,442,"值 x , y he"]],[442,442],[452,452]]],[1536761149945,["DreamK@RDK-PC",[[-1,450,"he"]],[452,452],[450,450]]],[1536761165604,["DreamK@RDK-PC",[[1,450,"和 z ，如果 x.eau"]],[450,450],[463,463]]],[1536761166321,["DreamK@RDK-PC",[[-1,461,"au"]],[463,463],[461,461]]],[1536761196588,["DreamK@RDK-PC",[[1,461,"quals(y) 返回 true，并且 y.equals(z"]],[461,461],[491,491]]],[1536761200452,["DreamK@RDK-PC",[[1,491,") f"]],[491,491],[494,494]]],[1536761201050,["DreamK@RDK-PC",[[-1,493,"f"]],[494,494],[493,493]]],[1536761207829,["DreamK@RDK-PC",[[1,493,"返回 true 。"]],[493,493],[502,502]]],[1536761208595,["DreamK@RDK-PC",[[-1,501,"。"]],[502,502],[501,501]]],[1536761211232,["DreamK@RDK-PC",[[1,501,"，那么"]],[501,501],[504,504]]],[1536761212203,["DreamK@RDK-PC",[[1,504,"\n\n"]],[504,504],[505,505]]],[1536761214317,["DreamK@RDK-PC",[[-1,505,"\n"]],[505,505],[504,504]]],[1536761223229,["DreamK@RDK-PC",[[1,504," x.equals "]],[504,504],[514,514]]],[1536761224224,["DreamK@RDK-PC",[[-1,513," "]],[514,514],[513,513]]],[1536761225469,["DreamK@RDK-PC",[[1,513,"()"]],[513,513],[515,515]]],[1536761227828,["DreamK@RDK-PC",[[1,514,"z"]],[514,514],[515,515]]],[1536761243144,["DreamK@RDK-PC",[[1,516," 必须返回 ttue"]],[516,516],[526,526]]],[1536761244188,["DreamK@RDK-PC",[[-1,523,"tue"]],[526,526],[523,523]]],[1536761247469,["DreamK@RDK-PC",[[1,523,"rue。"]],[523,523],[527,527]]],[1536761248156,["DreamK@RDK-PC",[[1,528,"\n"]],[527,527],[528,528]]],[1536761253084,["DreamK@RDK-PC",[[-1,528,"\n"],[1,529,"* yiz"]],[528,528],[533,533]]],[1536761254094,["DreamK@RDK-PC",[[-1,530,"yiz"]],[533,533],[530,530]]],[1536761261520,["DreamK@RDK-PC",[[1,530,"一致性"]],[530,530],[533,533]]],[1536761376636,["DreamK@RDK-PC",[[1,533,"：比较的对象 x ，y "]],[533,533],[545,545]]],[1536761405775,["DreamK@RDK-PC",[[1,545,"信息没有修改，多次调用 equals 方法的返回值必须一致"]],[545,545],[574,574]]],[1536761406063,["DreamK@RDK-PC",[[1,574,"\n\n"]],[574,574],[575,575]]],[1536761491804,["DreamK@RDK-PC",[[-1,575,"\n"],[1,576,"》"]],[575,575],[576,576]]],[1536761492879,["DreamK@RDK-PC",[[-1,575,"》"],[1,576,"\n"]],[576,576],[575,575]]],[1536761494323,["DreamK@RDK-PC",[[-1,575,"\n"],[1,576,"> "]],[575,575],[577,577]]],[1536761534848,["DreamK@RDK-PC",[[1,577,"覆盖 equals 方法的一些诀窍"]],[577,577],[594,594]]],[1536761535318,["DreamK@RDK-PC",[[1,594,"\n\n"]],[594,594],[595,595]]],[1536761541611,["DreamK@RDK-PC",[[-1,595,"\n"],[1,596,"* "]],[595,595],[597,597]]],[1536761590331,["DreamK@RDK-PC",[[1,597,"shi"]],[597,597],[600,600]]],[1536761591152,["DreamK@RDK-PC",[[-1,597,"shi"]],[600,600],[597,597]]],[1536761599203,["DreamK@RDK-PC",[[1,597,"使用 == jian"]],[597,597],[607,607]]],[1536761600208,["DreamK@RDK-PC",[[-1,603,"jian"]],[607,607],[603,603]]],[1536761615864,["DreamK@RDK-PC",[[1,603,"检查参数是否为对象的引用"]],[603,603],[615,615]]],[1536761625340,["DreamK@RDK-PC",[[1,615,"，如果是返回 true"]],[615,615],[626,626]]],[1536761625900,["DreamK@RDK-PC",[[1,626,"\n\n"]],[626,626],[627,627]]],[1536761648846,["DreamK@RDK-PC",[[-1,627,"\n"],[1,628,"* 使用 instanceof 检查"]],[627,627],[645,645]]],[1536761684219,["DreamK@RDK-PC",[[1,645," "]],[645,645],[646,646]]],[1536761685315,["DreamK@RDK-PC",[[-1,645," "]],[646,646],[645,645]]],[1536761704245,["DreamK@RDK-PC",[[1,645,"参数是否为正确的类型，即判断是否属于者"]],[645,645],[664,664]]],[1536761704705,["DreamK@RDK-PC",[[-1,663,"者"]],[664,664],[663,663]]],[1536761709831,["DreamK@RDK-PC",[[1,663,"这一类"]],[663,663],[666,666]]],[1536761710020,["DreamK@RDK-PC",[[1,666,"\n\n"]],[666,666],[667,667]]],[1536761736873,["DreamK@RDK-PC",[[-1,667,"\n"],[1,668,"* 将参数转换成"]],[667,667],[675,675]]],[1536761740805,["DreamK@RDK-PC",[[1,675,"正确的类型"]],[675,675],[680,680]]],[1536761741289,["DreamK@RDK-PC",[[1,680,"\n\n"]],[680,680],[681,681]]],[1536761742699,["DreamK@RDK-PC",[[-1,681,"\n"],[1,682,"* "]],[681,681],[683,683]]],[1536761857109,["DreamK@RDK-PC",[[1,683,"判断对象的成员"]],[683,683],[690,690]]],[1536761864407,["DreamK@RDK-PC",[[1,690,"变量值是否相等"]],[690,690],[697,697]]],[1536761864766,["DreamK@RDK-PC",[[1,697,"\n\n"]],[697,697],[698,698]]],[1536761911431,["DreamK@RDK-PC",[[-1,698,"\n"],[1,699,"* 编写完之后，检查是否对称，一致，可传递"]],[698,698],[719,719]]],[1536761911843,["DreamK@RDK-PC",[[1,719,"\n\n"]],[719,719],[720,720]]],[1536761966605,["DreamK@RDK-PC",[[-1,720,"\n"],[1,721,"* 不要将 equals 方法参数 Object 改为其他类型"]],[720,720],[751,751]]],[1536761966824,["DreamK@RDK-PC",[[1,751,"\n\n"]],[751,751],[752,752]]],[1536761977090,["DreamK@RDK-PC",[[-1,752,"\n"],[1,753,"* 覆盖 equals "]],[752,752],[764,764]]],[1536761994404,["DreamK@RDK-PC",[[1,764,"时必须覆盖 hashCode"]],[764,764],[778,778]]],[1536761994716,["DreamK@RDK-PC",[[1,778,"\n\n"]],[778,778],[779,779]]],[1536762009106,["DreamK@RDK-PC",[[-1,779,"\n"],[1,780,"## 2.fu"]],[779,779],[786,786]]],[1536762009804,["DreamK@RDK-PC",[[-1,784,"fu"]],[786,786],[784,784]]],[1536762011806,["DreamK@RDK-PC",[[1,784,"覆盖"]],[784,784],[786,786]]],[1536762014087,["DreamK@RDK-PC",[[-1,784,"覆盖"]],[786,786],[784,784]]],[1536762018540,["DreamK@RDK-PC",[[1,784," 覆盖equals"]],[784,784],[793,793]]],[1536762021114,["DreamK@RDK-PC",[[1,787," "]],[787,787],[788,788]]],[1536762036046,["DreamK@RDK-PC",[[1,794," 时总要"]],[794,794],[798,798]]],[1536762040293,["DreamK@RDK-PC",[[1,798,"覆盖 哈市"]],[798,798],[803,803]]],[1536762041175,["DreamK@RDK-PC",[[-1,801,"哈市"]],[803,803],[801,801]]],[1536762044932,["DreamK@RDK-PC",[[1,801,"hashcode"]],[801,801],[809,809]]],[1536762047753,["DreamK@RDK-PC",[[-1,805,"c"]],[806,806],[805,805]]],[1536762049275,["DreamK@RDK-PC",[[1,805,"C"]],[805,805],[806,806]]],[1536762051164,["DreamK@RDK-PC",[[1,809,"\n\n"]],[809,809],[810,810]]],[1536762055330,["DreamK@RDK-PC",[[-1,810,"\n"],[1,811,"## 3. "]],[810,810],[816,816]]],[1536762150491,["DreamK@RDK-PC",[[1,816,"始终要覆盖 toString"]],[816,816],[830,830]]],[1536762152592,["DreamK@RDK-PC",[[1,830,"\n\n"]],[830,830],[831,831]]],[1536762157113,["DreamK@RDK-PC",[[-1,831,"\n"],[1,832,"## "]],[831,831],[834,834]]],[1536762180339,["DreamK@RDK-PC",[[1,834,"4. 谨慎覆盖 clone"]],[834,834],[847,847]]],[1536762180865,["DreamK@RDK-PC",[[1,847,"\n\n"]],[847,847],[848,848]]],[1536762217161,["DreamK@RDK-PC",[[-1,848,"\n"],[1,849,"## 5. 考虑实现 Comparable "]],[848,848],[870,870]]],[1536762218494,["DreamK@RDK-PC",[[1,870,"接口"]],[870,870],[872,872]]],[1536762219137,["DreamK@RDK-PC",[[1,872,"\n\n"]],[872,872],[873,873]]],[1536762303003,["DreamK@RDK-PC",[[1,810,"\n"]],[809,809],[810,810]]],[1536762467349,["DreamK@RDK-PC",[[1,810,"两个对象根据 equals 方法比较是"]],[810,810],[829,829]]],[1536762477389,["DreamK@RDK-PC",[[1,829,"相等的，那么他们同"]],[829,829],[838,838]]],[1536762478109,["DreamK@RDK-PC",[[-1,837,"同"]],[838,838],[837,837]]],[1536762502572,["DreamK@RDK-PC",[[1,837,"通过hashCode 返回的值也必须相等"]],[837,837],[857,857]]],[1536762599769,["DreamK@RDK-PC",[[1,858,"\n"]],[857,857],[858,858]]],[1536762611497,["DreamK@RDK-PC",[[1,858,"可以使用自动生成的。"]],[858,858],[868,868]]]]]]}